
# üîê CASCATA AUTHENTICATION ARCHITECTURE: DEEP DIVE

Este documento detalha clinicamente como o sistema de autentica√ß√£o do Cascata funciona, desde a estrutura de dados at√© a inje√ß√£o de contexto no PostgreSQL para RLS.

## 1. O Conceito: Identidade Concatenada (1:N)

O Cascata n√£o trata "Login com Google" e "Login com Senha" como coisas distintas na camada de aplica√ß√£o. Ele opera com uma separa√ß√£o estrita entre **O Usu√°rio (A Alma)** e **A Credencial (A Chave)**.

### A Estrutura Dual

1.  **auth.users (A Alma / O √Çncora)**
    *   Este √© o `UUID` real do usu√°rio.
    *   √â aqui que o RLS (Row Level Security) se amarra.
    *   Se o usu√°rio trocar de e-mail, perder a senha ou desconectar o Google, este UUID **nunca muda**.
    *   Cont√©m metadados globais (`raw_user_meta_data`).

2.  **auth.identities (As Chaves / O Concatenador)**
    *   √â aqui que a m√°gica da "concatena√ß√£o" acontece.
    *   Um registro em `auth.users` pode ter **v√°rias** entradas em `auth.identities`.
    *   **Exemplo Pr√°tico:**
        *   Entrada 1: Provider `email`, Identifier `joao@gmail.com` -> Aponta para User UUID `A1`
        *   Entrada 2: Provider `google`, Identifier `1234567890` -> Aponta para User UUID `A1`
        *   Entrada 3: Provider `phone`, Identifier `+551199999999` -> Aponta para User UUID `A1`
    *   Isso permite que voc√™ crie sistemas onde o usu√°rio come√ßa com E-mail e depois "Linka" o Google, sem criar duas contas separadas.

---

## 2. O Schema do Banco de Dados (Isolamento F√≠sico)

Cada projeto Cascata tem seu pr√≥prio schema `auth` isolado. Nada √© compartilhado entre projetos.

```sql
-- Resumo da Tabela auth.users
CREATE TABLE auth.users (
    id UUID PRIMARY KEY,           -- O "auth.uid()" retorna isso
    email_confirmed_at TIMESTAMPTZ, -- Trava de seguran√ßa
    banned BOOLEAN,                -- Kill-switch instant√¢neo
    ...
);

-- Resumo da Tabela auth.identities
CREATE TABLE auth.identities (
    provider TEXT,    -- 'email', 'google', 'github', 'cpf'
    identifier TEXT,  -- O valor √∫nico naquele provider
    user_id UUID,     -- Link para auth.users
    password_hash,    -- S√≥ existe se provider == 'email'
    ...
    UNIQUE(provider, identifier)
);
```

**Por que isso √© nativo?**
Mesmo o login padr√£o (E-mail/Senha) √© tratado apenas como mais um *provider* na tabela de identidades. N√£o existe tratamento especial para senha na tabela de usu√°rios. Isso torna o sistema agn√≥stico a m√©todo de login.

---

## 3. O Fluxo de Vida de uma Requisi√ß√£o (Como o RLS funciona)

Aqui est√° o segredo de como o `auth.uid()` funciona sem que o banco saiba de sess√µes. Ocorre uma **Troca de Contexto** a cada milissegundo.

### Passo 1: O Passaporte (JWT)
Quando o usu√°rio loga (seja por Google, Senha ou Magic Link), o Backend (Node.js) valida a credencial na tabela `auth.identities`. Se v√°lido, ele assina um **JWT (JSON Web Token)** usando a `JWT_SECRET` do projeto.

O JWT cont√©m:
```json
{
  "sub": "uuid-do-auth-users",  <-- O √Çncora
  "role": "authenticated",      <-- O Papel
  "email": "user@email.com",
  "exp": 1715000000
}
```

### Passo 2: A Chegada no Data Plane
O usu√°rio faz um request: `GET /rest/v1/todos`.
Ele envia o header: `Authorization: Bearer <JWT>`.

O Backend (Express/Middleware):
1.  Verifica a assinatura do JWT (garante que n√£o foi falsificado).
2.  Extrai o `sub` (UUID) e `role`.
3.  Pega uma conex√£o do Pool do banco de dados (que √© gen√©rica, usada por todos).

### Passo 3: A Inje√ß√£o de Contexto (A M√°gica)
Antes de rodar a query do usu√°rio, o Backend executa comandos de sess√£o local no Postgres **dentro da mesma transa√ß√£o**:

```sql
-- O Backend roda isso invisivelmente:
BEGIN;
-- Define a role do banco para limitar poderes gerais
SET LOCAL ROLE cascata_api_role; 

-- Injeta vari√°veis de configura√ß√£o de sess√£o (GUCs)
SELECT set_config('request.jwt.claim.sub', 'uuid-do-usuario', true);
SELECT set_config('request.jwt.claim.role', 'authenticated', true);
SELECT set_config('request.jwt.claim.email', 'email-do-usuario', true);

-- AGORA roda a query do usu√°rio
SELECT * FROM public.todos;

-- Limpa tudo antes de devolver a conex√£o para o Pool
COMMIT;
```

### Passo 4: A Fun√ß√£o auth.uid()
Agora faz sentido as fun√ß√µes que criei na migration `013`.
Quando o Postgres est√° rodando o `SELECT` acima e encontra uma pol√≠tica RLS:

```sql
CREATE POLICY "Meus Dados" ON public.todos
USING ( user_id = auth.uid() );
```

A fun√ß√£o `auth.uid()` faz exatamente isto:
```sql
-- Ele l√™ a vari√°vel que injetamos no Passo 3
SELECT current_setting('request.jwt.claim.sub', true)::uuid;
```

### Resultado
O PostgreSQL "pensa" que aquela conex√£o pertence √†quele usu√°rio espec√≠fico apenas durante aqueles milissegundos da execu√ß√£o. Isso garante isolamento total de dados entre usu√°rios, mesmo usando um Pool de conex√µes compartilhado.

---

## 4. Onde a "Revolu√ß√£o" Acontece

O seu conceito de "Concatena√ß√£o" √© poderoso porque desacopla a **Autentica√ß√£o** (provar quem sou) da **Autoriza√ß√£o** (o que meu UUID pode fazer).

1.  **Multi-Factor Nativo:** Como as identidades s√£o uma lista (`1:N`), voc√™ pode exigir no futuro que um usu√°rio tenha *duas* identidades validadas (ex: Senha + SMS) antes de emitir o JWT.
2.  **Identidades Corporativas:** Voc√™ pode vincular um Login Google Workspace E um Login Microsoft AD ao mesmo UUID. O usu√°rio v√™ os mesmos dados independente de por onde entrou.
3.  **Migra√ß√£o Invis√≠vel:** Se voc√™ quiser migrar de Auth0 para Cascata, basta criar as entradas em `auth.identities` mantendo os UUIDs em `auth.users`. O usu√°rio nem percebe.

## 5. Resumo Cl√≠nico

*   **Front-end:** Envia credenciais -> Recebe JWT.
*   **Back-end:** Valida Credencial -> Emite JWT -> Recebe Request -> Injeta Vari√°veis no SQL -> Executa Query.
*   **Database:** N√£o sabe de nada, apenas l√™ `current_setting('request.jwt.claim.sub')` via `auth.uid()` e filtra as linhas.

Esta arquitetura √© "Stateless" (sem estado) no servidor, infinitamente escal√°vel e extremamente segura, pois a regra de seguran√ßa vive junto com o dado (no banco), n√£o no c√≥digo Javascript.
